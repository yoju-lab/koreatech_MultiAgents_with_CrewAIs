# CrewAI 핵심 개념 Lab 실습

이 실습 문서는 **CrewAI** 라이브러리의 핵심 개념을 초급자도 이해할 수 있도록 안내합니다. 두 가지 파트로 구성되어 있으며, VS Code에서 실행 가능한 Python 코드 예제(`02-1.hello_crewai.py`와 `02-2.researcher_writer.py`)를 단계별로 설명합니다. 1부에서는 CrewAI의 기본 **구조**(Agent, Task, Crew 등)를 이해하고, 2부에서는 두 에이전트가 **협업**하여 작업을 수행하는 예제를 실습합니다. 각 파트별로 **목표**, **사전 요구사항**, **코드 및 상세 설명**, **실행 방법**, **예상 출력 예시**를 포함하고 있으니 차례대로 따라해 보세요.

## 1부: CrewAI 구조 이해 (Hello CrewAI 예제)

**설명:** 첫 번째 실습에서는 CrewAI의 기본 구성요소를 파악하고, 간단한 "Hello World"에 해당하는 환영 인사말을 생성해봅니다. 하나의 AI 에이전트가 하나의 작업(Task)을 수행하도록 설정하고, CrewAI를 통해 실행 및 결과를 출력합니다.

### 목표
- CrewAI의 핵심 구성 요소인 **Agent(에이전트)**, **Task(태스크)**, **Crew(크루)**의 역할과 상호 관계 이해  
- 단일 에이전트를 사용한 간단한 **환영 인사 메시지** 생성 실습  
- CrewAI 코드 실행 흐름(kickoff -> 결과 출력) 경험  

### 사전 요구사항
- **Python 3.x** 개발 환경 (예: VS Code)  
- CrewAI 라이브러리 및 필요 패키지 설치: `pip install crewai python-dotenv`  
- **OpenAI API 키** 발급 및 환경 설정:
  - OpenAI 계정을 통해 API 키를 준비합니다.
  - 프로젝트 디렉토리에 `.env` 파일을 만들고 다음과 같이 키를 저장합니다. 예시:  
    ```text
    OPENAI_API_KEY=sk-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    ```  
  - (`python-dotenv` 패키지가 `.env` 파일로부터 키를 불러오는 데 사용됩니다.)  
- 인터넷 연결 (OpenAI API 호출을 위해 필요)  

### 코드 및 상세 설명

이제 `02-1.hello_crewai.py` 코드의 주요 부분을 살펴보면서 CrewAI의 구조를 이해해보겠습니다. 

#### 1) 초기 설정 및 Agent 생성

먼저 필요한 라이브러리를 임포트하고, 환경 변수(.env 파일)를 로드한 후 **에이전트(Agent)**를 생성합니다:

```python
# 필요한 라이브러리 임포트
from crewai import Agent, Task, Crew, Process  # CrewAI 핵심 클래스들
from dotenv import load_dotenv
import os

# 0. 환경 변수 로드 (.env에서 OPENAI_API_KEY 불러오기)
load_dotenv()  # .env 파일에 정의된 환경변수를 로드합니다.
# OPENAI_API_KEY가 환경변수로 설정되었다면, openai 패키지가 이를 자동으로 사용합니다.

# 1. Agent 생성: role, goal, backstory 설정
agent = Agent(
    role="AI 어시스턴트",            # 에이전트의 역할
    goal="사용자에게 간단한 환영 인사를 제공",  # 에이전트가 달성할 목표
    backstory="당신은 친절한 AI 비서로, 언제나 정중하고 도움이 되는 인사를 건넵니다."  # 에이전트의 성격/배경
)
```

**설명:** 먼저 `crewai` 패키지에서 **Agent**, **Task**, **Crew**, **Process** 클래스를 가져옵니다. `.env` 파일에 저장된 OpenAI API 키를 `load_dotenv()`로 불러와 환경변수로 등록합니다. 이렇게 하면 CrewAI가 내부적으로 OpenAI의 API를 사용할 때 해당 키를 자동으로 참조할 수 있습니다. 

그 다음, `Agent` 객체를 생성합니다. **Agent**는 AI 모델의 **역할**을 정의한 것으로, 사람으로 치면 팀의 한 구성원입니다. 위 코드에서는 하나의 `agent`를 만들며 세 가지 속성을 설정했습니다:

- `role`: 에이전트의 역할이나 직책을 나타냅니다. 여기서는 `"AI 어시스턴트"`로 지정하여 이 에이전트를 “AI 비서” 역할로 설정했습니다.
- `goal`: 에이전트가 궁극적으로 달성해야 할 **목표**입니다. 예제에서는 `"사용자에게 간단한 환영 인사를 제공"`으로 설정하여, 이 에이전트의 목표는 사용자에게 환영 메시지를 만드는 것임을 명시했습니다.
- `backstory`: 에이전트의 배경 이야기나 성격을 서술합니다. 이는 에이전트의 **말투**나 **행동 방식**에 영향을 주는 설정입니다. `"친절한 AI 비서로, 언제나 정중하고 도움이 되는 인사"`라고 넣어주어, 이 에이전트가 항상 친절하고 정중한 톤으로 인사말을 건네도록 유도했습니다.

즉, **Agent**는 AI 언어 모델에게 “너는 이런 역할이고, 이런 목표와 성격을 가졌다”라고 **프롬프트**를 설정하는 것과 비슷합니다. 이렇게 Agent를 정의하면, 이후에 이 Agent는 자신에게 주어진 목표와 성격에 맞춰 응답을 생성하게 됩니다.

#### 2) Task 생성 (작업 지시)

이제 해당 에이전트에게 수행시킬 **태스크(Task)**를 정의해보겠습니다. 태스크는 구체적으로 어떤 **작업 지시**를 내릴지와 그 **기대 결과물**이 무엇인지를 포함합니다:

```python
# 2. Task 생성: description, expected_output, agent 지정
task = Task(
    description="사용자에게 환영 인사 한 마디를 작성하세요.",   # 에이전트가 수행할 작업 내용
    expected_output="한 줄의 따뜻한 환영 메시지",            # 기대하는 출력 결과물
    agent=agent                                    # 이 태스크를 수행할 에이전트
)
```

**설명:** `Task` 객체를 생성하며 세 가지 주요 요소를 설정했습니다:

- `description`: 에이전트에게 줄 **작업 지시**를 서술합니다. 여기서는 `"사용자에게 환영 인사 한 마디를 작성하세요."`라고 명령하여, 에이전트가 해야 할 일은 "사용자에게 보내는 환영 인사말 한 줄 쓰기"가 됩니다. 이 설명은 결국 AI 모델에게 전달되는 **프롬프트**의 핵심 내용입니다.
- `expected_output`: 기대하는 출력 결과 형태를 묘사합니다. `"한 줄의 따뜻한 환영 메시지"`라고 작성하여, 결과가 어떻게 나오길 바라는지를 인간이 이해할 수 있게 메모해둔 것입니다. 이 필드는 주로 개발자나 사용자가 결과물을 예상하는 데 도움을 주며, CrewAI는 이 정보를 참고하여 에이전트의 응답을 평가하거나 체크할 수 있습니다. (즉, 한 줄로 된 따뜻한 톤의 메시지를 기대한다는 뜻입니다.)
- `agent`: 이 작업을 **누가 수행할지**를 지정합니다. 앞서 만든 `agent`를 할당함으로써, 해당 작업은 우리가 정의한 "AI 어시스턴트" 에이전트가 수행하게 됩니다.

정리하면, **Task**는 "어떤 작업을, 어떤 에이전트가, 어떤 형태의 결과를 목표로 수행할 것인가"를 캡슐화한 것입니다. 이번 태스크는 단순히 환영 인사를 작성하는 것이며, 우리의 에이전트에게 그 임무를 부여했습니다.

#### 3) Crew 생성 (에이전트와 태스크로 크루 구성)

이제 **Crew(크루)**를 만들어보겠습니다. Crew는 말 그대로 하나 이상의 에이전트와 하나 이상의 태스크를 묶어 하나의 **팀**이나 **프로젝트**로 구성한 것입니다. Crew 객체에는 작업을 수행할 **에이전트 목록**, 해결해야 할 **태스크 목록**, 그리고 태스크들을 어떻게 진행할지 결정하는 **프로세스(Process)** 전략이 포함됩니다:

```python
# 3. Crew 생성: 에이전트와 태스크를 크루로 구성 (순차 프로세스 설정)
crew = Crew(
    agents=[agent],               # 크루에 속한 에이전트 목록 (여기서는 1개)
    tasks=[task],                 # 크루가 수행할 태스크 목록 (여기서는 1개)
    process=Process.sequential,   # 순차적 진행 방식으로 태스크 실행
    verbose=True                  # 실행 중 상세한 로그 출력 여부
)
```

**설명:** `Crew` 객체를 생성하면서 다음과 같이 설정했습니다:

- `agents=[agent]`: 이 Crew에 소속된 에이전트 리스트를 지정합니다. 현재 예제에서는 에이전트 하나만 있기 때문에 `[agent]`로 리스트를 구성했습니다. (만약 여러 Agent를 만들었다면 여기에 모두 추가하여 팀을 꾸릴 수 있습니다.)
- `tasks=[task]`: Crew가 수행할 태스크들의 리스트입니다. 마찬가지로 이번에는 하나의 작업만 있으므로 `[task]`로 설정했습니다. **CrewAI에서는 주어진 tasks를 적절히 분배하여 수행**하게 됩니다.
- `process=Process.sequential`: **프로세스**는 Crew가 태스크를 실행하는 **방식**이나 **전략**을 정의합니다. `Process.sequential`로 지정하면 **태스크들을 순차적으로** 실행합니다. 즉, `tasks` 리스트에 주어진 순서대로 하나씩 차례로 수행합니다. (참고로 CrewAI에는 이 외에도 평행(병렬) 실행이나 기타 고급 전략이 있을 수 있지만, 이 실습에서는 가장 기본인 순차 실행을 사용합니다.)
- `verbose=True`: 실행 과정을 **자세히 출력할지 여부**입니다. `True`로 설정하면 에이전트가 작업을 수행하면서 주고받는 메시지나 내부 로그를 콘솔에 상세히 출력합니다. 초급자 학습에서는 이 옵션을 켜 두어 **에이전트에게 어떤 프롬프트가 전달되고, 어떤 응답이 오는지 확인**하는 것이 도움이 됩니다. (불필요한 로그를 보고 싶지 않다면 False로 끌 수 있습니다.)

이렇게 `Crew`를 구성하면, 이제 CrewAI는 **어떤 에이전트(들)**이 **어떤 태스크(들)**를 어떤 **방식(프로세스)**으로 수행해야 하는지를 모두 알게 됩니다. 하나의 Crew는 팀 프로젝트와 유사하며, `kickoff`를 호출하면 이 정의된 계획에 따라 작업이 이루어집니다.

#### 4) Crew 실행 및 결과 출력

마지막으로, Crew를 실행하여 에이전트가 실제로 태스크를 수행하도록 하고, 그 **최종 결과물을 출력**해보겠습니다:

```python
# 4. Crew 실행: kickoff() 메서드로 태스크 수행 시작
result = crew.kickoff()

# 5. 실행 결과 출력
print("최종 결과:", result)
```

**설명:** `crew.kickoff()`를 호출하면 앞서 설정한 대로 CrewAI가 에이전트에게 태스크를 할당하여 수행을 시작합니다. **kickoff**는 말 그대로 팀의 작업을 시작하는 명령이며, 이 함수가 끝나면 모든 태스크의 처리가 완료됩니다.

이 예제에서는 태스크가 하나뿐이므로 `crew.kickoff()`의 반환값 `result`는 곧 **그 태스크의 출력 결과**가 됩니다. 이어서 `print("최종 결과:", result)`를 통해 최종 산출물을 콘솔에 표시합니다. 

> **Note:** CrewAI에서 `kickoff()`의 반환 타입은 여러 태스크가 있는 경우 **모든 태스크의 결과를 포함한 객체**일 수 있습니다. 하지만 단일 태스크의 경우 편의상 해당 작업의 결과 문자열로 간주되어 출력됩니다. (만약 복수 태스크인 경우 `result.tasks_output`과 같은 속성으로 각 결과에 접근할 수 있습니다. 이는 2부 실습에서 다룹니다.)

이제 코드 설명이 모두 끝났습니다. 정리하면, **1부 실습 코드의 흐름**은 다음과 같습니다:
1. OpenAI API 키 설정 등 **환경 준비** (dotenv 이용)
2. **Agent 정의** – AI 모델의 역할/목표/성격 설정 (예: 친절한 AI 어시스턴트)
3. **Task 정의** – 수행할 작업 내용과 기대 결과, 담당 에이전트 지정 (예: 환영 인사 작성)
4. **Crew 구성** – 에이전트와 태스크를 모아 팀을 만들고, 순차 실행 프로세스 설정
5. **Crew 실행** – `kickoff()`로 태스크 수행 시작, 완료 후 결과 획득
6. **결과 출력** – 최종 생성된 환영 인사 메시지를 화면에 출력

이 코드를 실행함으로써 CrewAI의 가장 기본적인 동작 방식을 체험해볼 수 있습니다.

### 실행 방법

이제 VS Code에서 `02-1.hello_crewai.py` 스크립트를 실행해보겠습니다:

1. 위에서 준비한 **.env 파일**이 현재 프로젝트 디렉토리에 존재하고 OPENAI_API_KEY가 올바르게 설정되어 있는지 확인합니다.
2. VS Code에서 해당 Python 파일을 엽니다. (또는 터미널에서 `python 02-1.hello_crewai.py` 명령을 사용할 수도 있습니다.)
3. **실행**: VS Code의 'Run' 기능을 사용하거나 터미널에서 파일을 실행합니다. 
4. 콘솔에 verbose 로그와 함께 최종 결과가 출력됩니다. verbose=True로 설정했으므로 **에이전트가 어떤 프롬프트를 받고 어떤 응답을 생성하는지 과정**이 쭉 나타날 것입니다. 로그의 마지막 부분에 `최종 결과:` 라는 문구와 함께 에이전트가 생성한 환영 메시지가 표시됩니다.

**TIP:** 만약 실행했는데 OPENAI API 키 관련 오류가 발생한다면, .env 파일에 키가 제대로 입력되었는지 확인하세요 (파일 인코딩은 일반 텍스트여야 하고, `"OPENAI_API_KEY="` 앞에 불필요한 공백이나 따옴표가 없어야 합니다).

### 예상 출력 예시

정상적으로 실행되었다면, 콘솔 맨 마지막 줄에 아래처럼 **환영 인사 한 줄**이 출력됩니다 (내용은 매번 조금씩 다를 수 있습니다):

```
최종 결과: 안녕하세요! CrewAI 실습에 오신 것을 환영합니다 😊
```

위와 같이 에이전트가 **친절한 인사말**을 한 줄 생성하여 출력하는 것을 확인할 수 있습니다.  
(예시에서는 "안녕하세요! CrewAI 실습에 오신 것을 환영합니다 😊"라고 나왔지만, OpenAI의 AI 모델 특성상 표현은 다소 랜덤하게 바뀔 수 있습니다. 예를 들어 "`최종 결과: 반갑습니다! 즐거운 경험 되시길 바랍니다.`"와 같이 나올 수도 있습니다. 중요한 점은 **정중하고 따뜻한 환영 메시지 한 문장**이면 목표를 달성한 것입니다.)

이로써 1부 실습을 통해 **CrewAI의 기본 구조**—Agent, Task, Crew가 어떻게 연계되고 동작하는지—를 경험해보았습니다.

---

## 2부: 간단한 에이전트 협업 예제 (Researcher & Writer 시나리오)

**설명:** 두 번째 실습에서는 **멀티 에이전트 협업**의 개념을 배웁니다. 두 명의 에이전트(역할이 다른 AI)와 두 개의 태스크를 만들어, 한 에이전트의 결과를 다른 에이전트가 이어받아 사용하는 **연계 작업**을 수행해볼 것입니다. 이 예제 시나리오는 "AI 연구원" 에이전트가 정보를 조사하면, "기술 작가" 에이전트가 그 정보를 바탕으로 요약 정리를 작성하는 흐름입니다.

### 목표
- 둘 이상의 에이전트를 CrewAI로 구성하고 **역할 분담**시키는 방법 이해  
- **이전 작업 결과를 다음 작업에 활용**하는 태스크간 **컨텍스트** 연계 사용법 학습  
- 멀티에이전트 시스템의 이점 (전문성 분담, 협업을 통한 결과 도출) 체험  

### 사전 요구사항
- **1부 실습과 동일**합니다:
  - Python 3.x, CrewAI 라이브러리 설치, OpenAI API 키 (.env 설정) 등이 이미 준비되었다고 가정합니다.
  - 만약 별도로 이 부분만 실행한다면, 앞서 언급한 환경 설정 단계를 다시 확인하세요. (특히 .env 설정과 `pip install crewai python-dotenv` 등이 완료되어야 합니다.)

### 코드 및 상세 설명

이제 `02-2.researcher_writer.py` 코드를 단계별로 살펴보면서, 두 에이전트가 순차적으로 협업하는 방법을 알아보겠습니다. 

#### 1) 환경 설정 (.env 로 OpenAI 키 로드)

```python
import os
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process

# 1. .env 파일에서 OpenAI API 키 불러오기
load_dotenv()
openai_api_key = os.getenv('OPENAI_API_KEY')
if openai_api_key is None:
    raise EnvironmentError("OPENAI_API_KEY is not set in .env file. Please add your OpenAI API key to .env.")
```

**설명:** 1부와 마찬가지로 필요한 패키지를 임포트한 후, `.env` 파일에서 OpenAI API 키를 불러옵니다. 여기서는 불러온 키를 `openai_api_key` 변수에 저장하고, 만약 키가 설정되어 있지 않을 경우 `EnvironmentError`를 일으켜 실행을 중단하도록 했습니다. 이 부분은 사용자의 환경 설정 실수를 확인하기 위한 코드입니다. (.env에 키가 없으면 친절한 안내 메시지를 주면서 종료합니다.) 

이 확인을 통과했다면 API 키 준비는 완료된 것이므로, 다음 단계로 넘어갑니다.

#### 2) 에이전트 정의 (연구원과 작가 역할)

이번에는 두 개의 **Agent**를 정의합니다. 각 에이전트는 서로 다른 역할과 목표를 가지고 있으며, 협업을 위해 순차적으로 사용될 예정입니다:

```python
# 2. 에이전트 정의 (연구원, 작가)
researcher = Agent(
    role="AI Researcher",
    goal="멀티 에이전트 시스템의 주요 장점을 3가지 조사하여 설명합니다.",
    backstory="다년간 AI 트렌드를 연구해온 전문가입니다."
)
writer = Agent(
    role="Technical Writer",
    goal="연구 결과를 바탕으로 간략한 결론을 작성합니다.",
    backstory="복잡한 정보를 쉽게 요약하는 작문 전문가입니다."
)
```

**설명:** 두 개의 Agent 객체, `researcher`와 `writer`를 생성했습니다. 각 에이전트의 **역할(role)**과 **목표(goal)**, **배경(backstory)**을 살펴보면:

- **researcher 에이전트**:
  - `role`: `"AI Researcher"` – AI 연구원 역할입니다.
  - `goal`: `"멀티 에이전트 시스템의 주요 장점을 3가지 조사하여 설명합니다."` – 목표는 "멀티 에이전트 시스템의 주요 장점 3가지를 조사하여 설명"하는 것입니다. 이 목표는 에이전트가 수행할 작업의 방향성을 나타냅니다.
  - `backstory`: `"다년간 AI 트렌드를 연구해온 전문가입니다."` – 이 에이전트는 다년간 AI 분야를 연구한 **전문가**라는 배경을 부여했습니다. 따라서 말투나 접근 방식이 전문적이고 조사에 능숙한 캐릭터로 행동할 것입니다.

- **writer 에이전트**:
  - `role`: `"Technical Writer"` – 기술 전문 작가 또는 문서 작성자 역할입니다.
  - `goal`: `"연구 결과를 바탕으로 간략한 결론을 작성합니다."` – 목표는 "위 연구 결과를 토대로 짧은 결론을 작성"하는 것입니다. 즉, 앞의 연구원이 조사한 내용을 받아 요약 정리하는 역할입니다.
  - `backstory`: `"복잡한 정보를 쉽게 요약하는 작문 전문가입니다."` – 오랜 작문 경험을 지닌 전문가로 설정하여, 복잡한 내용을 쉽게 풀어서 요약해주는 성향을 갖습니다.

이처럼 두 에이전트는 **서로 다른 전문성**을 가지도록 구성되었습니다. 연구원 에이전트는 조사를 잘 하는 캐릭터, 작가 에이전트는 요약하고 글을 잘 쓰는 캐릭터로 만든 것입니다. 실제로 AI 모델이 이러한 설정을 얼마나 정확히 따르는지는 프롬프트 설계에 달려 있지만, CrewAI는 이러한 정보를 토대로 에이전트별로 **컨텍스트를 구분**해주고 각자 역할에 충실하도록 도와줍니다.

#### 3) 태스크 정의 및 연계 설정

이제 앞서 만든 두 에이전트에게 각각 할 일을 부여하는 **Task**를 정의합니다. 첫 번째 태스크는 연구원 에이전트가 수행할 "조사" 작업이고, 두 번째 태스크는 작가 에이전트가 수행할 "작성" 작업입니다. 특히 두 번째 태스크에는 **첫 번째 태스크의 결과를 참고**하도록 컨텍스트를 전달합니다:

```python
# 3. 태스크 정의 (조사 태스크, 작성 태스크)
research_task = Task(
    description="멀티 에이전트 시스템의 주요 장점 3가지를 조사하고 각 장점을 간략히 설명하세요.",
    expected_output="3가지 장점에 대한 간단한 설명 (bullet point 목록)",
    agent=researcher
)
write_task = Task(
    description="위 조사 결과를 참고하여, 멀티 에이전트 시스템의 장점에 대한 짧은 결론을 작성하세요.",
    expected_output="3~4문장으로 구성된 결론 단락",
    agent=writer,
    context=[research_task]  # 이전 태스크의 결과를 활용
)
```

**설명:** 두 개의 Task 객체를 정의하였습니다:

- `research_task`: 
  - **설명(description)**: `"멀티 에이전트 시스템의 주요 장점 3가지를 조사하고 각 장점을 간략히 설명하세요."`  
    → 연구원 에이전트에게 주어진 작업 지시입니다. 멀티 에이전트 시스템(복수의 AI 에이전트로 구성된 시스템)의 핵심 장점 세 가지를 찾아 각각에 대해 간략한 설명을 하라는 요구사항입니다.  
  - **기대 출력(expected_output)**: `"3가지 장점에 대한 간단한 설명 (bullet point 목록)"`  
    → 결과는 3개의 주요 장점을 찾아 **간단히 설명**하는 것이므로, bullet point 목록 형태로 3줄 정도 나오길 기대한다는 뜻입니다. (예: "- 병렬 처리로 인한 속도 향상", "- 전문성 분담을 통한 높은 품질" 등)  
  - **담당 에이전트(agent)**: `researcher`  
    → 이 태스크는 앞서 정의한 AI 연구원 역할의 에이전트에게 할당되었습니다.

- `write_task`: 
  - **설명(description)**: `"위 조사 결과를 참고하여, 멀티 에이전트 시스템의 장점에 대한 짧은 결론을 작성하세요."`  
    → 두 번째 작업 지시로, **작성자 에이전트**에게 주는 명령입니다. "위 조사 결과"라고 되어 있는데, 이는 첫 번째 태스크(조사 결과)를 참고하여 결론을 쓰라는 의미입니다. 즉, writer 에이전트는 researcher 에이전트가 찾아낸 내용을 보고 종합 정리를 해야 합니다.
  - **기대 출력(expected_output)**: `"3~4문장으로 구성된 결론 단락"`  
    → 결과물은 3~4문장 정도의 하나의 단락으로 된 **결론 요약**이어야 합니다. 조사된 장점을 기반으로 간략히 전체 요지를 정리한 글이 나오길 기대합니다.
  - **담당 에이전트(agent)**: `writer`  
    → 이 태스크는 기술 작가 역할의 에이전트에게 할당했습니다.
  - **컨텍스트(context)**: `[research_task]`  
    → **중요:** 이 부분은 첫 번째 태스크와 두 번째 태스크를 **연결**하는 핵심입니다. `context=[research_task]`로 설정하면, CrewAI는 `write_task`를 수행할 때 **이전에 수행된 `research_task`의 결과를 컨텍스트로 제공**합니다. 쉽게 말해, writer 에이전트에게 "앞서 연구원이 이런 내용을 조사해놨으니 참고해"라고 알려주고 그 정보를 입력으로 넘겨주는 것입니다. 
      
      CrewAI 내부적으로는 `research_task`가 완료된 후 그 **output(출력)**을 `write_task`의 입력 프롬프트에 포함시켜 줄 것입니다. 따라서 writer 에이전트는 따로 웹검색을 하거나 빈 종이에서 시작할 필요 없이, researcher의 결과를 받아 보고 그것을 요약하는 작업을 하게 됩니다.

이러한 방식으로 `Task` 간의 의존성을 설정하면, **멀티에이전트 협업**이 가능해집니다. 하나의 에이전트가 생산한 정보나 결과를 다른 에이전트가 활용하여 이어서 작업함으로써, 각자의 전문성을 살리면서도 흐름 있는 작업 수행을 할 수 있습니다.

#### 4) Crew 생성 (에이전트 팀 구성 및 프로세스 설정)

두 에이전트와 두 태스크를 모두 정의했으니, 이를 종합하여 하나의 Crew로 구성합니다. 1부에서는 에이전트도 하나, 태스크도 하나였지만 이제는 여러 구성원이 있으므로 Crew 설정에 각각 리스트를 넘겨줍니다:

```python
# 4. 크루 생성 (순차적 프로세스 설정)
crew = Crew(
    agents=[researcher, writer],
    tasks=[research_task, write_task],
    process=Process.sequential,
    verbose=True
)
```

**설명:** `Crew` 객체를 생성하는 것은 1부와 기본적으로 동일하지만, 이번에는 **두 명의 에이전트와 두 개의 태스크**가 목록으로 전달됩니다:

- `agents=[researcher, writer]`: 이 Crew에는 researcher 에이전트와 writer 에이전트, 두 AI 에이전트가 속해 있습니다. CrewAI는 이 목록을 보고 어떤 에이전트들이 협동하는 팀인지를 파악합니다.
- `tasks=[research_task, write_task]`: 해결해야 할 작업으로 두 개의 태스크를 넣었습니다. 리스트의 순서가 중요합니다. 현재 `Process.sequential` 설정이므로 **리스트에 나열된 순서대로** 작업이 진행됩니다. 즉, `research_task`를 먼저 수행하고, 완료되면 `write_task`를 수행하는 순서입니다.
- `process=Process.sequential`: 순차 처리 프로세스를 사용합니다. 첫 번째 태스크부터 차례로 두 번째 태스크까지 진행합니다. (만약 병렬 처리 등을 원한다면 다른 프로세스를 선택할 수 있지만, 이 예제에서는 순차가 자연스럽습니다. 조사 후 작성이므로 순서가 중요하기 때문입니다.)
- `verbose=True`: 1부와 마찬가지로 작업 진행 중의 상세 로그를 출력합니다. 두 에이전트 간 주고받는 내용이나 컨텍스트 전달 과정을 콘솔에서 확인할 수 있습니다. (두 개의 에이전트가 있으므로 verbose 출력에는 어떤 에이전트가 응답했는지 등을 구분하여 표시될 것입니다.)

이로써 Crew 구성은 완료되었습니다. CrewAI는 이제 "researcher와 writer라는 두 에이전트에게, 먼저 research_task를 하고 나서 write_task를 하라"는 시나리오를 인지하게 되었습니다.

#### 5) Crew 실행 및 결과 출력

마지막으로, Crew를 실행하여 실제로 두 에이전트가 순차적으로 협업을 수행하게 하고, 각 태스크의 결과를 출력해보겠습니다:

```python
# 5. 크루 실행 및 결과 출력
crew_output = crew.kickoff()

# 6. 각 태스크의 결과를 순차적으로 출력
for idx, task_output in enumerate(crew_output.tasks_output, start=1):
    print(f"\n[Task {idx} Output]\n{task_output}\n")
```

**설명:** `crew.kickoff()`를 호출하여 크루를 실행합니다. 이제 **researcher 에이전트**가 첫 번째 태스크(조사)를 수행하고, 완료되면 **writer 에이전트**가 두 번째 태스크(결론 작성)를 수행하게 됩니다. `crew.kickoff()`의 반환값을 이번에는 `crew_output` 변수에 저장했는데, 이 객체는 **모든 태스크의 실행 결과를 담고 있는 구조**입니다. 

이 `crew_output`에는 각 태스크의 출력물이 순서대로 저장되어 있습니다. 이를 출력하기 위해 `crew_output.tasks_output` 리스트를 활용했습니다. `tasks_output`은 태스크 리스트와 동일한 순서로 결과를 가지고 있으므로, `enumerate`를 사용하여 `[Task 1 Output]`, `[Task 2 Output]` 형태로 라벨을 붙여가며 콘솔에 출력합니다. 

`print(f"\n[Task {idx} Output]\n{task_output}\n")` 부분은 보기 좋게 개행과 라벨을 넣어 출력하는 역할을 합니다:
- `Task 1 Output` 섹션에는 researcher 에이전트가 조사한 **3가지 장점 목록**이 출력될 것이고,
- `Task 2 Output` 섹션에는 writer 에이전트가 작성한 **결론 단락**이 출력될 것입니다.

결국 사용자(우리)는 두 단계의 결과물을 모두 확인함으로써, 에이전트들이 **협업하여 작업을 완수**한 최종 산출물을 얻게 됩니다.

코드의 흐름을 요약하면 다음과 같습니다:
1. **두 에이전트 정의** – (researcher, writer) 각기 다른 역할과 목표 설정
2. **두 태스크 정의** – (research_task: 조사, write_task: 작성) 및 태스크 간 **context 연결** 설정
3. **Crew 구성** – 두 에이전트와 두 태스크를 하나의 크루로 묶고 순차 실행 설정
4. **Crew 실행** – `kickoff()`로 먼저 researcher가 조사 수행 → 그 결과를 바탕으로 writer가 결론 작성
5. **결과 출력** – 각 태스크의 출력물을 순서대로 표시 (조사 결과 목록 + 결론 글)

이 과정을 통해 **멀티 에이전트 시스템의 이점**을 실감할 수 있습니다. 한 에이전트가 찾은 정보를 다른 에이전트가 활용함으로써, 혼자 할 때보다 효율적이고 전문화된 결과를 얻을 수 있습니다.

### 실행 방법

이제 2부의 코드를 실제로 실행해봅시다:

1. VS Code에서 `02-2.researcher_writer.py` 파일을 엽니다.
2. 1부 실습에서 .env 설정과 패키지 설치를 이미 완료했다면 곧바로 실행하면 됩니다. (만약 환경 설정이 안 되어 있다면 먼저 **사전 요구사항**의 내용을 충족시켜야 합니다.)
3. **실행**: 이전과 마찬가지로 VS Code에서 Run하거나 터미널에서 `python 02-2.researcher_writer.py`를 실행합니다.
4. 콘솔에 verbose 로그가 쭉 출력되고, 이어서 각 태스크의 결과가 `[Task 1 Output]`, `[Task 2 Output]` 섹션으로 나타날 것입니다. 

verbose 로그를 켜 두었으므로 researcher 에이전트가 OpenAI API를 통해 정보를 찾아내는 과정, writer 에이전트가 결론을 작성하는 과정에서 주고받는 **프롬프트와 응답 내용**이 자세히 나타날 것입니다. 이러한 로그는 두 에이전트가 어떻게 협업하는지 이해하는 데 도움이 됩니다. (예를 들어, writer 에이전트의 프롬프트에 researcher의 결과가 포함되어 전달되는 것을 볼 수 있습니다.)

모든 작업이 끝나면 마지막에 우리가 `print`한 깔끔한 결과 요약이 등장합니다.

### 예상 출력 예시

아래는 실행 후 콘솔에 표시될 **예상 결과물 예시**입니다 (실제 출력은 매번 달라질 수 있지만, 형태는 유사할 것입니다):

```
[Task 1 Output]
- 작업 병렬화로 인한 **처리 속도 향상**  
  여러 에이전트가 동시에 작업을 수행하여 전체 작업 시간이 단축됩니다.
- **전문성 분담**을 통한 **성과 향상**  
  각 에이전트가 잘하는 분야의 작업을 맡아 전반적인 결과 품질이 높아집니다.
- **높은 유연성**과 **견고성**  
  한 에이전트의 실패나 한계가 있어도 다른 에이전트들이 보완하여 안정적으로 작업을 마칠 수 있습니다.

[Task 2 Output]
요약하면, 멀티 에이전트 시스템은 개별 에이전트의 강점을 모아 더욱 **효율적이고 견고한 결과**를 도출합니다. 여러 에이전트가 협력함으로써 속도와 전문성이 향상되고, 단일 에이전트로는 해결하기 어려운 복잡한 문제도 효과적으로 처리할 수 있습니다. 이러한 이유로 멀티 에이전트 접근 방식은 다양한 상황에서 **높은 효율성과 신뢰성**을 제공합니다.
```

위 결과 예시는 다음과 같은 내용을 보여줍니다:

- **[Task 1 Output]**: 연구원 에이전트가 찾아낸 "멀티 에이전트 시스템의 장점 3가지"입니다. 보시다시피 세 가지 bullet point로 정리되어 있고, 각 장점마다 굵은 키워드와 짧은 설명이 붙어 있습니다. (예시는 이해를 돕기 위해 일부 단어를 굵게 표시했지만, 실제 출력에서는 AI가 자체 형식으로 답을 줄 것입니다. 핵심은 세 가지 항목의 리스트라는 형식입니다.)
- **[Task 2 Output]**: 작가 에이전트가 작성한 결론 단락입니다. Task 1의 내용을 요약 및 재구성하여 두 문단 정도의 간략한 결론을 제공하고 있습니다. 예시에서는 두 문장으로 구성되어 있으며, 멀티 에이전트 시스템의 효율성, 전문성, 신뢰성 향상을 강조하는 결론을 보여주고 있습니다. 실제 출력도 이와 비슷하게 **앞서 bullet 목록의 주요 포인트를 하나의 단락으로 종합**한 형태가 될 것입니다.

중요한 것은 writer의 출력이 실제로 researcher의 조사 결과를 **참고하여 작성**되었다는 점입니다. 예시를 보면 Task 1의 bullet에 등장했던 키워드(속도 향상, 전문성, 견고성 등)가 Task 2의 결론에도 반영되어 있는 것을 알 수 있습니다. 이렇게 앞선 태스크의 **컨텍스트**가 다음 태스크에 전달되어 활용됨으로써, 두 에이전트가 마치 바톤을 터치하며 협업한 효과를 얻었습니다.

---

이상 2부 실습을 통해 **CrewAI를 사용한 멀티 에이전트 협업**을 경험해보았습니다. 

## 결론 및 추가 팁

이번 Lab 실습에서는 CrewAI의 핵심 개념인 **Agent(에이전트)**, **Task(태스크)**, **Crew(크루)**, 그리고 **Process(실행 프로세스)**의 역할을 이해하고, 간단한 시나리오에서 AI 에이전트들이 협력하여 작업을 수행하는 과정을 실습했습니다. 초급자라도 따라할 수 있도록 자세히 설명했으므로, 직접 코드를 실행해보면서 AI 에이전트들의 협업 동작을 관찰해 보셨기를 바랍니다.

**추가 팁:** 
- 에이전트의 역할이나 목표를 변경하면 출력이 어떻게 달라지는지 실험해보세요. 예를 들어, 연구원 에이전트의 goal을 다른 주제로 바꾸거나, 작가 에이전트의 backstory를 바꾸면 결과물 어조가 달라질 수 있습니다.
- 새로운 Task를 추가하여 3명 이상의 에이전트 협업을 구성해보는 등 응용도 가능하니, CrewAI의 구조를 응용하여 다양한 **시나리오**를 만들어볼 수 있습니다.
- CrewAI는 여기서 다룬 것 외에도 고급 기능들(예: 에이전트 간 **Tool** 사용, **병렬 프로세스**, **매니저 에이전트 지정** 등)을 제공하고 있습니다. 추후 더 복잡한 프로젝트에 도전할 때 이러한 기능들도 학습하면 더욱 강력한 AI 에이전트 팀을 구현할 수 있습니다.

이번 실습을 통해 얻은 개념들을 바탕으로, 더 풍부한 AI 협업 실험을 이어나가길 바랍니다. **Happy Crewing!**

