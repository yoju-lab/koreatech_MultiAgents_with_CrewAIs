# 외부 도구(Tools) 연동하기

## 실습 목표 및 사전 요구사항

이 실습의 목표는 **CrewAI 에이전트에 외부 도구를 연동하여 활용하는 방법**을 배우는 것입니다. 이를 통해 에이전트가 **웹 검색**, **웹 페이지 내용 추출(스크래핑)**, **계산 수행**, **벡터 데이터베이스 검색** 등 **LLM 모델 단독으로는 할 수 없는 작업을 수행**하도록 도울 수 있습니다. 

이번 실습을 통해 다음을 학습합니다:

- CrewAI의 **`Tool` 개념** 이해 및 에이전트에 외부 도구를 제공하는 방법  
- 제공된 코드(`tools.py`)의 각 도구 클래스 구현 상세 설명 (DuckDuckGo 검색, 웹 스크래퍼, 계산기)  
- 예제 시나리오 파일(`04-1.scenario_news.py`, `04-2.scenario_recipe.py`, `04-3.scenario_travel.py`)을 실행하며 **도구 사용 흐름**을 단계별로 경험  
- 도구 입력 형식과 관련된 **잠재적 이슈 및 디버깅 방법** 이해  
- 각 시나리오 실행 시 **기대 출력 예시**를 확인하고 결과를 해석  

**사전 요구사항:** 이 실습을 진행하려면 Python과 기본적인 프로그래밍 지식이 필요하며, CrewAI 라이브러리가 설치되어 있어야 합니다. 또한 DuckDuckGo 검색 및 웹 스크래핑을 위해 인터넷 연결이 필요하며, VS Code 환경에서 Python 파일을 실행하는 방법을 알고 있어야 합니다.

## 각 도구의 역할 및 코드 설명

`tools.py` 파일에는 CrewAI에서 사용할 **외부 도구(`Tool`) 클래스**들이 정의되어 있습니다. 모든 도구 클래스는 `BaseTool`을 상속하며, 각 클래스는 고유한 `name`(도구 이름)과 `description`(설명)을 가지고 있고, `_run` 메서드에 **도구의 실제 동작**을 구현합니다. 에이전트(LLM)는 이 `name`과 `description` 정보를 바탕으로 어떤 도구를 언제 사용할지 판단하며, `_run` 메서드를 통해 **외부 작업을 수행**한 뒤 그 결과를 받아옵니다. 

아래에서는 `tools.py`에 구현된 **4개의 도구 클래스**에 대해 **코드 라인별로 상세히 설명**합니다.

### DuckDuckGoSearchTool (웹 검색 도구)

DuckDuckGoSearchTool은 **웹 검색을 수행**하는 도구로, 최신 정보를 찾기 위해 DuckDuckGo 검색엔진을 활용합니다. 이 도구를 사용하면 에이전트가 인터넷에서 최신 자료를 검색할 수 있습니다.

```python
class DuckDuckGoSearchTool(BaseTool):
    name: str = "DuckDuckGo Search"
    description: str = "DuckDuckGo에서 최신 정보를 검색합니다."

    def _run(self, query: str) -> str:
        duckduckgo_tool = DuckDuckGoSearchRun()
        response = duckduckgo_tool.invoke(query)
        return response
```

- **라인 1-3:** `DuckDuckGoSearchTool` 클래스 정의 부분입니다. CrewAI의 기본 도구 클래스 `BaseTool`을 상속받고 있으며, `name`과 `description` 속성을 설정합니다. 여기서 `name`은 도구의 이름(에이전트가 인식할 이름)이고, `description`은 이 도구의 기능을 설명합니다. `"DuckDuckGo에서 최신 정보를 검색합니다."`라는 설명을 통해 에이전트는 이 도구가 **웹 검색 용도**임을 알 수 있습니다.

- **라인 5-9:** `_run` 메서드의 구현 부분입니다. `query: str` 매개변수를 받아서 DuckDuckGo 검색을 수행한 뒤 결과를 문자열로 반환합니다. 구체적으로:
  - `DuckDuckGoSearchRun()` 인스턴스를 생성하여 DuckDuckGo 검색 기능을 준비합니다. (`DuckDuckGoSearchRun`은 Langchain 커뮤니티에서 제공하는 DuckDuckGo 검색 도구 래퍼입니다.)
  - `duckduckgo_tool.invoke(query)`를 호출하여 DuckDuckGo에 `query` 문자열로 검색을 수행합니다. DuckDuckGoSearchRun의 `invoke` 메서드는 검색 결과를 문자열 형태로 반환해 줍니다.
  - 마지막에 그 `response` 문자열을 그대로 반환합니다.  
   
이렇게 함으로써, **에이전트가 `_run`을 호출하면 DuckDuckGo 검색 결과 문자열을 얻게** 됩니다. 예를 들어 에이전트가 “최신 AI 뉴스”를 검색하고자 이 도구를 사용하면, DuckDuckGoSearchTool은 DuckDuckGo에서 해당 키워드를 검색하고 검색 결과(예를 들어 요약된 웹 페이지 리스트 등)을 문자열로 전달해줍니다.

### WebScraperTool (웹 스크래퍼 도구)

WebScraperTool은 **웹 페이지의 본문 내용을 추출**하는 도구입니다. 에이전트가 특정 URL을 주면 해당 페이지를 가져와서 텍스트 내용을 반환합니다. 이를 통해 에이전트는 **검색으로 찾은 웹 페이지의 상세 정보**를 읽을 수 있습니다.

```python
class WebScraperTool(BaseTool):
    name: str = "웹 스크래퍼"
    description: str = "웹페이지 내용을 추출합니다."

    def _run(self, url: str) -> str:
        loader = WebBaseLoader(url)
        docs = loader.load()
        return docs[0].page_content if docs else "내용을 찾을 수 없습니다."
```

- **라인 1-3:** `WebScraperTool` 클래스 정의와 `name`, `description` 설정입니다. 이름은 "웹 스크래퍼", 설명은 "웹페이지 내용을 추출합니다."로 되어 있어, **주어진 URL의 페이지 내용을 가져오는 도구**임을 나타냅니다.

- **라인 5-9:** `_run(self, url: str)` 구현 부분입니다. 이 메서드는 `url` 문자열을 받아 해당 웹 페이지의 내용을 반환합니다.
  - `WebBaseLoader(url)`를 통해 URL에 대한 로더(loader)를 생성합니다. `WebBaseLoader`는 Langchain 커뮤니티의 웹 페이지 로더로, 주어진 URL의 HTML을 가져와 문서로 변환해 줍니다.
  - `loader.load()`를 호출하면 해당 URL의 페이지를 로드하여 문서 리스트를 반환합니다. 보통 `[docs]` 리스트 형태로 결과가 나오는데, `docs[0]`가 첫 번째 문서 (페이지 내용)을 담고 있습니다.
  - `return docs[0].page_content if docs else "내용을 찾을 수 없습니다."`는 만약 문서를 성공적으로 불러왔다면 그 중 첫 번째 문서의 본문 내용을 반환하고, 만약 실패하거나 내용이 없다면 `"내용을 찾을 수 없습니다."`라는 메시지를 반환합니다.  
   
즉, **유효한 URL을 입력으로 주면 해당 페이지의 텍스트를 추출하여 리턴**하며, 잘못된 URL이거나 페이지를 불러올 수 없을 경우 사용자에게 "내용을 찾을 수 없습니다."라고 알려주도록 구현되어 있습니다. 이 도구를 통해 에이전트는 검색 단계에서 얻은 링크의 실제 내용을 읽고 요약하거나 분석할 수 있게 됩니다.

### CalculatorTool (계산기 도구)

CalculatorTool은 **수학 계산을 수행하는 도구**입니다. 에이전트가 수치 계산이나 수식 평가가 필요할 때 이 도구를 사용하여 Python의 `eval` 함수를 통해 계산을 수행할 수 있습니다. 예를 들어 예산 합계 계산이나 단위 변환 등의 작업을 도와줄 수 있습니다.

```python
class CalculatorTool(BaseTool):
    name: str = "계산기"
    description: str = "수학 계산을 수행합니다."

    def _run(self, expression: str) -> str:
        try:
            return str(eval(expression))
        except Exception as e:
            return f"계산 오류: {e}"
```

- **라인 1-3:** `CalculatorTool` 클래스 정의와 이름, 설명 설정입니다. 이름은 "계산기", 설명은 "수학 계산을 수행합니다."로 정의되어 있어 **수학적 표현식을 계산해주는 도구**임을 알 수 있습니다.

- **라인 5-10:** `_run(self, expression: str)` 메서드 구현 부분입니다. `expression`이라는 문자열로 수학 표현식을 받아 평가한 결과를 반환합니다.
  - `eval(expression)`을 이용하여 전달된 문자열 수식을 실행합니다. 예를 들어 `"2+2*3"`이라는 문자열이 들어오면 `eval`이 이를 파이썬 코드로 실행하여 결과 `8`을 얻습니다.
  - 계산 결과는 숫자일 수 있으므로 `str(...)`로 문자열로 변환한 뒤 반환합니다.
  - `try`/`except` 블록을 사용하여 계산 중 오류가 발생하는 경우를 처리합니다. 만약 `eval` 실행 중 예외가 발생하면 (예를 들어 잘못된 수식이나 보안상의 이유로 허용되지 않은 연산 등), `"계산 오류: {e}"` 형식으로 오류 메시지를 문자열로 반환합니다.  
   
이 도구를 통해 **에이전트는 산술 계산이나 간단한 수식 평가를 정확히 수행**할 수 있습니다. 예를 들어, 여행 일정 도우미 에이전트가 예산 합계를 계산하거나, 레시피 도우미 에이전트가 단위 환산을 해야 할 때 이 CalculatorTool을 사용하게 됩니다.

## 실습 실행 방법 (VS Code 기준)

이제 각 시나리오 파일을 실행하면서, 에이전트가 어떻게 도구를 사용하여 문제를 해결하는지 확인해보겠습니다. VS Code에서 실행할 때는 **통합 터미널을 열어 Python 파일을 직접 실행**하거나, 파일을 열고 `Run Python File` 기능을 이용하면 됩니다. 

**사전 준비 확인:** 
- `.env` 파일에 필요한 API 키 (예: OpenAI 키)가 설정되어 있는지 확인하세요. `tools.py`가 import될 때 자동으로 `load_dotenv()`를 통해 키를 로드합니다.
- 인터넷 연결이 되어 있어야 DuckDuckGo 검색과 웹 스크래퍼가 동작합니다.
- 각각의 `scenario` 파일이 같은 폴더에 있고 `tools.py`와 `crewai` 라이브러리를 잘 import할 수 있는 상태여야 합니다.

3개의 시나리오 (`뉴스`, `레시피`, `여행`)는 난이도가 순차적으로 올라가며, **뉴스 시나리오에서는 두 가지 도구(검색, 스크래퍼)**를, **레시피 시나리오도 동일한 두 도구를**, **여행 시나리오에서는 세 가지 도구(검색, 스크래퍼, 계산기)**를 사용합니다. 

각 시나리오 파일을 열어 주요 코드를 살펴보고, **어떤 역할의 에이전트가 어떤 도구를 사용**하는지 이해한 후 실행해보겠습니다.

### 뉴스 시나리오 실행 (`04-1.scenario_news.py`)

먼저 `04-1.scenario_news.py` 파일을 열어보면, **“뉴스 분석가” 에이전트**가 정의되어 있습니다. 이 에이전트는 **“최신 뉴스를 검색하여 요약”**하는 목표를 가지고 있으며, DuckDuckGoSearchTool과 WebScraperTool 두 가지 도구를 사용하도록 설정되어 있습니다.

코드의 중요한 부분을 보면 다음과 같습니다:

```python
# 도구 인스턴스 생성
search_tool = DuckDuckGoSearchTool()
scrape_tool = WebScraperTool()
calculator_tool = CalculatorTool()

news_agent = Agent(
    role="뉴스 분석가",
    goal="최신 뉴스를 검색하여 요약",
    backstory="뉴스 분석 전문 AI 기자",
    tools=[search_tool, scrape_tool],
    llm="gpt-4o-mini",
    verbose=True
)
news_task = Task(
    description="최근 인공지능 관련 뉴스 3건을 요약하고 링크 제공",
    expected_output="한국어로 작성된 뉴스 3건의 요약 및 링크",
    agent=news_agent
)
crew = Crew(
    agents=[news_agent], 
    tasks=[news_task], 
    process=Process.sequential,
    verbose=True
)
```

- **도구 인스턴스 생성:** 위 코드에서 먼저 `search_tool`, `scrape_tool`, `calculator_tool` 객체를 생성합니다. 이번 뉴스 시나리오에서는 **검색**과 **스크래퍼** 도구만 사용하므로, `news_agent`의 `tools` 리스트에 `search_tool`과 `scrape_tool`만 전달하고 있습니다. (계산기 도구 `calculator_tool`은 생성만 하고 사용되지 않았는데, 이는 모든 도구를 한번에 보여주기 위한 준비 코드로 보입니다.)

- **에이전트 설정:** `Agent(...)`를 생성할 때 역할(`role`), 목표(`goal`), 백스토리(`backstory`), 사용 도구들(`tools`), LLM 모델(`llm`), 그리고 `verbose=True` 등을 설정합니다. 
  - 역할은 "뉴스 분석가", 목표는 "최신 뉴스를 검색하여 요약", 백스토리는 "뉴스 분석 전문 AI 기자" 등으로 설정되어 있어 이 에이전트의 **정체성과 임무**를 서술합니다. 
  - `tools=[search_tool, scrape_tool]` 부분을 통해 앞서 생성한 두 도구를 에이전트에게 장착시킵니다. 이로써 에이전트는 **자유롭게 DuckDuckGo 검색과 웹 스크래핑 기능을 활용**할 수 있게 됩니다.
  - `llm="gpt-4o-mini"`는 에이전트의 언어모델(LLM)을 지정합니다. (예제이므로 경량화된 GPT-4 모델을 가정한 것으로 보입니다.)
  - `verbose=True`로 설정하면 에이전트의 내부 추론 과정과 도구 사용 로그가 콘솔에 상세히 출력됩니다. 이는 디버깅과 학습에 매우 유용하며, 우리가 실행 결과를 해석하는 데 도움을 줄 것입니다.

- **작업(Task) 설정:** `news_task = Task(...)`로 에이전트에게 줄 과제를 정의합니다. `description`에는 실제 지시할 내용이 들어가는데, `"최근 인공지능 관련 뉴스 3건을 요약하고 링크 제공"`이라고 되어 있습니다. 즉, **“최근의 인공지능 관련 뉴스 기사 3건을 찾아 요약하고 각각의 링크를 제시해 달라”**는 요청입니다. `expected_output`에는 기대되는 출력의 형태를 적어두었는데, `"한국어로 작성된 뉴스 3건의 요약 및 링크"`라고 명시되어 있습니다. 이 값은 주로 평가나 문서화 용도로 사용되며, 에이전트 출력의 목표를 사람이 이해하기 쉽게 표현한 것입니다. 마지막으로 이 Task가 사용할 `agent`로 우리가 만든 `news_agent`를 지정합니다.

- **Crew 생성:** `Crew`는 에이전트와 작업을 묶어서 실행을 관리하는 객체입니다. `agents=[news_agent]`와 `tasks=[news_task]`로 하나의 에이전트에게 하나의 작업을 할당했습니다. `process=Process.sequential`은 **순차 처리 모드**를 지정하는 것으로, 작업들을 한 번에 하나씩 수행하게 합니다 (hierarchical 등 다른 모드도 있으나 여기서는 단순 실행). `verbose=True`로 설정하여 Crew 레벨에서도 로그를 출력하도록 했습니다.

- **실행 시작:** 마지막으로 `crew.kickoff()`를 호출하면 정의된 에이전트가 주어진 작업을 수행하게 됩니다. `result = crew.kickoff()`의 반환값으로 최종 결과(에이전트의 응답)가 나오며, 이를 `print("[뉴스 시나리오 응답]\n", result)`로 출력하고 있습니다.

설정을 이해했으니, 이제 실제로 뉴스를 요약하는 에이전트가 어떻게 동작하는지 **코드를 실행**해 보겠습니다. VS Code 터미널에서 다음과 같이 입력하십시오:

```bash
python 04-1.scenario_news.py
```

실행하면 콘솔에 `verbose=True`에 의해 **에이전트의 사고 과정과 도구 사용 단계**가 출력됩니다. 예를 들어, **DuckDuckGoSearchTool을 사용**하여 웹 검색을 하고, **WebScraperTool을 사용**하여 각 뉴스 링크의 내용을 읽어오는 순서 등이 로그로 나타날 것입니다. 

에이전트는 아마 다음과 같은 추론 과정을 거칠 것입니다 (개략적인 예시):

1. "최근 인공지능 관련 주요 뉴스 3건이 무엇일까?"라고 스스로 생각한 뒤, **DuckDuckGo 검색 도구**를 이용해 관련 키워드로 검색을 시도합니다.  
2. DuckDuckGoSearchTool이 반환한 검색 결과 문자열을 보고, 그 중 적절한 뉴스 기사 링크들을 **파악하여 3개 선택**합니다. (에이전트 LLM이 검색 결과 텍스트에서 URL을 찾아낼 것입니다.)  
3. 선택된 각 링크에 대해 **WebScraperTool**을 호출하여 기사 본문 내용을 가져옵니다.  
4. 가져온 기사 내용을 바탕으로 **한글 요약문을 3개 작성**합니다. 각 요약에는 해당 기사 **링크도 함께 포함**합니다.  
5. 최종적으로 3건의 뉴스 요약과 링크를 하나의 응답으로 정리하여 출력합니다.

로그에는 이러한 흐름이 드러날 것이며, 마지막에 `[뉴스 시나리오 응답]` 레이블과 함께 에이전트의 최종 답변이 출력됩니다. 이 최종 답변은 `expected_output`에 맞춰 **"뉴스 3건의 요약 및 링크"** 형식으로 되어 있을 것입니다.

### 레시피 시나리오 실행 (`04-2.scenario_recipe.py`)

다음은 `04-2.scenario_recipe.py` 파일을 실행해 보겠습니다. 이 시나리오에서는 **“요리 전문가” 에이전트**가 **채식 파스타 레시피를 추천하고 재료와 조리법을 안내**해줍니다. 사용되는 도구는 **검색(`DuckDuckGoSearchTool`)과 스크래퍼(`WebScraperTool`)**로, 뉴스 시나리오와 동일하게 두 가지 도구를 활용합니다 (계산기는 사용하지 않습니다).

레시피 시나리오의 코드 구조도 뉴스와 거의 비슷합니다. 주요 차이점은 에이전트의 역할/목표와 Task의 내용입니다:

- **에이전트 역할 및 목표:** `"요리 전문가"`로 설정되어 있고, 목표는 `"요리 레시피 추천 및 안내"`입니다. 백스토리로 `"글로벌 요리 전문가 AI 셰프"`라고 하여, 다양한 요리를 잘 아는 AI라는 설정입니다. 이 에이전트 역시 `tools=[search_tool, scrape_tool]`로 두 가지 도구를 장착하고 있습니다.

- **Task 내용:** `description`을 보면 `"채식 파스타 레시피 추천, 재료 및 조리법 안내"`라고 되어 있습니다. 즉 **사용자가 채식주의자를 위한 파스타 레시피를 알고 싶어하며, 그에 대한 요리명, 필요한 재료, 자세한 조리 방법을 안내해 달라**는 요청입니다. `expected_output`에는 `"한국어로 작성된 채식 파스타 레시피(재료 및 조리법)"`이라고 명시되어 있습니다.

이 설정을 바탕으로, 요리 전문가 에이전트는 **파스타 레시피를 찾기 위해 웹 검색**을 하고, **관련 레시피 페이지를 스크래핑**하여 정보를 얻은 뒤, **적절한 레시피를 한국어로 정리하여 출력**하게 됩니다.

VS Code 터미널에서 레시피 시나리오를 실행합니다:

```bash
python 04-2.scenario_recipe.py
```

실행 시 로그를 통해 에이전트의 진행 과정을 볼 수 있습니다. 예상되는 흐름은 다음과 같습니다:

1. 에이전트가 DuckDuckGoSearchTool을 사용하여 "채식 파스타 레시피" 등의 키워드로 **웹 검색**을 합니다.
2. 검색 결과에서 인기 있는 **채식 파스타 레시피 웹페이지 링크**를 찾아냅니다 (예를 들면 채식 볼로네제 파스타 블로그 글 등).
3. 해당 링크에 대해 WebScraperTool을 사용하여 **레시피 상세 내용을 수집**합니다.
4. 수집된 내용(요리 이름, 재료, 조리법)을 바탕으로 **한국어로 이해하기 쉬운 레시피 안내**를 작성합니다. 에이전트는 아마도 재료 목록을 정리하고, 순서대로 조리 단계를 나열해 줄 것입니다.
5. 완성된 레시피 설명을 출력합니다.

로그에서는 검색 질의, 스크래핑한 결과의 일부 등이 보이고, 마지막에 `[레시피 시나리오 응답]`과 함께 최종 레시피가 출력될 것입니다. 

뉴스 시나리오와 도구 사용 패턴은 유사하지만, 출력 내용은 **레시피 형식**이라는 점이 다릅니다. 이를 통해 **같은 도구라도 에이전트의 역할/목표에 따라 전혀 다른 결과물을 생성**할 수 있음을 관찰할 수 있습니다.

### 여행 시나리오 실행 (`04-3.scenario_travel.py`)

이제 세 번째로 `04-3.scenario_travel.py` 파일을 살펴보고 실행해보겠습니다. 이 시나리오는 **“여행 전문가” 에이전트**를 이용하여 **파리 5일 여행 일정과 예산 계획**을 세우는 예제입니다. 앞선 두 시나리오와 달리, 여기서는 **세 가지 도구**가 사용됩니다: **검색**, **스크래퍼**, **계산기**. (ChromaDB 검색 도구는 사용되지 않습니다.)

코드에서 눈여겨볼 부분은 다음과 같습니다:

```python
travel_agent = Agent(
    role="여행 전문가",
    goal="최적의 여행 일정과 예산 계획 제공",
    backstory="다년간의 여행 플래너 경험 보유",
    tools=[search_tool, scrape_tool, calculator_tool],
    llm="gpt-4o-mini",
    verbose=True
)
travel_task = Task(
    description="파리 5일 여행 일정(문화, 미식 포함), 예산은 1000달러 (항공 300달러, 숙박 하루 100달러).",
    expected_output="한국어로 작성된 5일간 파리 여행에 대한 상세한 일정과 예산 계산 결과",
    agent=travel_agent
)
```

- **에이전트 설정:** 역할은 `"여행 전문가"`, 목표는 `"최적의 여행 일정과 예산 계획 제공"`으로 설정되어 있습니다. 백스토리는 `"다년간의 여행 플래너 경험 보유"`로 되어 있어 현실의 베테랑 여행 플래너처럼 행동할 것임을 시사합니다. `tools=[search_tool, scrape_tool, calculator_tool]`로 이전에 만든 세 가지 도구를 모두 활용할 수 있도록 했습니다. 이로써 여행 전문 에이전트는 **여행 정보를 검색하고**, **웹에서 상세 내용을 가져오고**, **예산 계산을 수행**하는 능력을 모두 갖추게 됩니다.

- **Task 내용:** `description`에는 요청 사항이 구체적으로 적혀 있습니다. *"파리 5일 여행 일정(문화, 미식 포함), 예산은 1000달러 (항공 300달러, 숙박 하루 100달러)."* 라고 명시되어 있는데, 이는 사용자가 **문화 체험과 미식 경험을 포함한 5일간의 파리 여행 일정을 계획**해주길 원하며, **전체 예산 1000달러(이 중 항공비 300달러, 숙박비 하루 100달러)**라는 제약 조건을 제시한 것입니다. `expected_output`에는 *"5일간 파리 여행에 대한 상세한 일정과 예산 계산 결과"*를 한국어로 작성할 것으로 기대된다고 쓰여 있습니다.

이 과제를 해결하기 위해, 여행 전문가 에이전트는 다음과 같은 접근을 할 것입니다:

1. **검색 도구**를 이용해 파리 여행에 대한 최신 정보나 추천 일정을 찾아봅니다 (예: "파리 5일 여행 추천", "파리 미식 여행 코스" 등).
2. 검색 결과에서 **유용한 일정 정보**나 **맛집/문화 장소 추천** 관련 링크를 찾아 **WebScraperTool**로 내용을 확인합니다. (예를 들어, 여행 블로그의 파리 여행기나 관광청 사이트의 정보를 읽을 수 있습니다.)
3. 수집한 정보를 토대로 **5일치의 상세 일정**을 구성합니다. 각 일자별로 오전/오후에 할 것과 방문지, 먹을 곳 등을 계획할 것입니다. 문화와 미식을 포함해야 하므로, 유명 관광지(루브르 박물관, 에펠탑, 몽마르뜨 등) + 현지 음식(프랑스 빵, 디너 코스, 카페 등)을 일정에 적절히 배치할 것입니다.
4. **예산 계산**을 위해 CalculatorTool을 활용합니다. 주어진 예산 내에서 계획이 적절한지 확인해야 하므로, 항공 300 + 숙박(예: 5일=4박, 4*100=400 또는 5*100=500달러) 등의 고정비를 합산하고, 남은 금액으로 일별 식비나 교통비 등이 커버되는지 계산할 수 있습니다. 
   - 에이전트는 예를 들어 `"300 + 100*5"` 같은 수식을 CalculatorTool에 넘겨서 숙박+항공 비용 합계를 계산하고, **총 비용**이나 **잔여 예산** 등을 산출할 것입니다.
5. 최종적으로 **일정표와 예산 요약**을 작성하여 응답으로 출력합니다. 일정은 각 날짜별로 목록으로 정리하고, 예산 부분에서는 계산된 결과를 포함하여 1000달러 예산을 어떻게 사용하게 되는지 설명할 것입니다.

이제 실제로 실행해서 결과를 확인해보겠습니다. 터미널에서 다음을 실행하세요:

```bash
python 04-3.scenario_travel.py
```

실행 로그를 살펴보면, 앞선 두 시나리오와 유사하게 검색 -> 스크랩 -> 응답 작성의 흐름이 보일 것입니다. 추가로 **계산기 도구 사용 로그**도 나타날 수 있습니다. 예를 들어 에이전트가 내부적으로 `"100 * 5 + 300"` 같은 표현식을 계산기에 보내고 `"800"`이라는 결과를 얻는 과정이 로그에 나타날 수 있습니다. (계산기 사용 결과는 에이전트의 사고 과정에 반영되어, 예산이 충분한지 판단하는 데 이용됩니다.)

마지막에 출력되는 `[여행 시나리오 응답]`은 **5일간의 파리 여행 일정과 예산 요약**을 담고 있을 것입니다. 이를 통해 에이전트가 세 가지 도구를 유기적으로 사용하여 복잡한 요구 사항(여행 일정 + 예산)을 충족시키는 것을 확인할 수 있습니다.

## 실행 예시 출력 결과

이 절차대로 세 가지 시나리오를 모두 실행했다면, 각각 콘솔에 에이전트의 **최종 응답 결과**가 출력되었을 것입니다. 이제 각 시나리오별로 예상되는 출력의 형태를 예시로 보여드리겠습니다. (주의: 실제 실행 결과는 매번 조금씩 다를 수 있지만, 아래 예시는 요구된 형식에 맞는 적절한 답변의 한 사례로 보면 됩니다.)

### 뉴스 시나리오 출력 예시

[뉴스 시나리오 응답]  
**1.** *오픈AI, GPT-4.1 모델군 공개* – 오픈AI는 최신 GPT-4.1 및 경량화 모델들을 발표하며 복잡한 작업에서의 성능 향상을 예고했습니다. – https://cio.com/openai-gpt41-news  
**2.** *구글, 최신 AI 모델 '제미나이 2.5' 발표* – 구글이 새로운 AI 언어 모델 제미나이 2.5를 공개하였으며, 경쟁 모델 대비 뛰어난 성능을 강조했습니다. – https://www.etnews.com/20250326000399  
**3.** *네이버·카카오, AI 중심 사업 재편 가속* – 국내 IT기업 네이버와 카카오는 인공지능을 핵심으로 사업 구조를 개편하고 있으며, 올해 2분기부터 가시적인 성과를 기대하고 있습니다. – https://news.nate.com/view/20250417n22786  

> 각 번호는 서로 다른 뉴스 기사에 대한 요약입니다. **굵은 글씨**로 기사 제목 또는 핵심 내용을 제시하고, 뒤에 해당 내용의 **간략한 요약**을 덧붙였습니다. 마지막에는 **해당 뉴스 출처의 링크**를 포함하여 사용자가 원문을 참고할 수 있도록 했습니다. 에이전트는 최신 AI 뉴스 3건을 선정하여 위와 같이 결과를 제시했습니다.

### 레시피 시나리오 출력 예시

[레시피 시나리오 응답]  
**추천 메뉴:** 지중해식 채소 파스타 (베지테리언 파스타)  

**재료:** 스파게티 면, 토마토, 가지, 주키니(호박), 파프리카, 올리브 오일, 마늘, 양파, 바질, 소금, 후추  

**조리 방법:**  
1. 채소 손질: 가지, 호박, 파프리카, 양파를 한 입 크기로 썰어주세요. 마늘은 다집니다. 토마토는 뜨거운 물에 살짝 데쳐 껍질을 벗기고 잘게 다져주세요.  
2. 소스 조리: 깊은 팬에 올리브 오일을 두르고 마늘과 양파를 볶아 향을 냅니다. 손질한 가지, 호박, 파프리카를 넣고 부드러워질 때까지 볶습니다. 다진 토마토를 넣고 바질, 소금, 후추로 간을 하여 약불에서 15분 정도 끓여 주세요. (걸쭉한 라타투이 소스가 됩니다.)  
3. 면 삶기: 스파게티 면을 팩에 표시된 시간대로 삶아서 알단테로 익힙니다. 삶은 면은 물기를 빼고 올리브 오일을 약간 버무려 둡니다.  
4. 마무리: 준비된 채소 토마토 소스에 삶은 면을 넣고 고루 섞습니다. 접시에 담아 바질 잎으로 장식하면 완성입니다.  

**설명:** 이 파스타는 고기를 사용하지 않고도 풍부한 맛을 내는 채식 레시피입니다. 가지와 호박 등 **신선한 제철 채소**를 사용해 건강하며, 올리브 오일과 허브로 지중해의 풍미를 느낄 수 있습니다. 조리법도 간단하여 집에서 쉽게 따라 할 수 있습니다. 맛있게 즐기세요!

> 위 응답은 **채식주의자를 위한 파스타 레시피** 한 가지를 추천한 예시입니다. 에이전트는 요리 이름과 함께 필요한 **재료 목록**을 제시하고, **순서별 조리 방법**을 상세히 안내했습니다. 마지막에는 해당 요리의 특징이나 팁을 간단히 설명하는 형태로 마무리했습니다. 실제 응답에서는 요리 이름이 다를 수도 있지만 (예: "베지 볼로네제 파스타" 등), 요구사항에 맞게 **재료와 조리법이 포함된 완전한 레시피**가 제공될 것입니다.

### 여행 시나리오 출력 예시

[여행 시나리오 응답]  

**파리 5일 여행 일정 제안:**  
- **Day 1:** 오전 – 파리 도착 후 숙소 체크인. 오후 – 루브르 박물관 탐방 (모나리자 등 주요 소장품 관람)【미술/문화】. 저녁 – 인근 레스토랑에서 프랑스식 전통 저녁 식사 (프렌치 오니온 수프 등)【미식】.  
- **Day 2:** 오전 – 에펠탑 방문 및 전망대에서 파리 시내 조망【문화】. 오후 – 샹젤리제 거리 산책 및 마카롱으로 유명한 카페 들르노트 방문【미식】. 저녁 – 세느강 유람선 디너 크루즈 (야경 감상).  
- **Day 3:** 오전 – 베르사유 궁전 당일치기 여행【문화】 (궁전 내부 투어 및 정원 산책). 오후 – 귀환 후 몽마르뜨 언덕 올라 사크레쾨르 대성당 관람. 저녁 – 몽마르뜨 근처 비스트로에서 프랑스 가정식 식사【미식】.  
- **Day 4:** 오전 – 오르세 미술관 방문 (인상주의 작품 감상)【문화】. 오후 – 마레 지구 탐방 및 현지 마켓에서 크루아상과 커피 브런치【미식】. 저녁 – 오페라 가르니에 외관 감상 및 주변 레스토랑에서 근사한 디너.  
- **Day 5:** 오전 – 노트르담 대성당 주변 산책 (※ 현재 내부 공사 중이라 외부만 감상)【문화】. 오후 – 센 강변을 따라 여유롭게 산책하며 기념품 쇼핑. 저녁 – 출국 전에 현지 비스트로에서 마지막 만찬 즐기기【미식】. 공항으로 이동하여 출국.  

**예산 계획:**  
- 항공권: 약 **$300** (왕복)  
- 숙박비: 약 **$500** (5박 × $100)  
- 식비 및 교통비: 약 **$200** (현지 식사, 지하철 이용 등)  
- **총합: $1000** (예산 한도 내에서 일정 계획)  

계획된 일정은 **문화 체험과 미식 경험**을 균형 있게 포함하고 있으며, 주어진 **예산 $1000을 적절히 활용**하도록 구성되었습니다. 항공과 숙박에 약 $800를 사용하고 나면 약 $200 정도가 남아 일별 식사와 시내 교통, 입장료 등에 활용됩니다. 전반적으로 예산 내에서 충분히 파리를 즐길 수 있는 일정입니다. 즐거운 여행 되시길 바랍니다!

> 위 응답 예시에서는 **5일간의 파리 여행 일정**을 하루하루 상세히 나열하고, 마지막에 **예산 사용 내역**을 정리했습니다. 각 일자별로 **문화적 볼거리**(박물관, 유적지 등)와 **미식 경험**(현지 음식, 레스토랑 등)이 포함되도록 균형 있게 제안되었습니다. 또한 예산 부분에서는 주어진 조건대로 항공비, 숙박비, 기타 경비를 합산하여 정확히 $1000에 맞췄음을 보여주고 있습니다 (CalculatorTool을 통해 `300 + 100*5 = 800` 등을 계산한 결과를 활용). 실제 에이전트의 응답에서도 이와 비슷하게 **일정 + 예산 요약** 형태로 결과가 나타나며, 사용자의 요구사항이 모두 반영되었는지 확인할 수 있습니다.

## 마무리 정리

이상으로, CrewAI에서 **외부 도구를 에이전트에 연동하여 활용하는 방법**을 실습했습니다. 이번 랩을 통해 아래의 중요한 개념과 기술을 배웠습니다:

- **Tool 개념:** LLM 기반 에이전트는 `Tool`을 통해 자신의 한계를 뛰어넘을 수 있습니다. 지식 컷오프나 계산 능력의 한계를, 웹 검색이나 계산기 등의 도구를 사용함으로써 보완할 수 있음을 확인했습니다. CrewAI에서는 `BaseTool` 클래스를 상속하여 커스텀 도구를 만들고, 에이전트에 `tools`로 할당하면 LLM이 필요에 따라 이를 호출해 문제를 해결합니다.

- **도구 구현 상세:** `tools.py`의 코드를 하나하나 살펴보면서, DuckDuckGoSearchTool (웹 검색), WebScraperTool (웹 콘텐츠 추출), CalculatorTool (수학 계산)의 **동작 원리와 사용법**을 이해했습니다. 특히 **DuckDuckGoSearchRun**을 이용한 웹 검색과, **LangChain WebBaseLoader**를 이용한 스크래핑 방법, 파이썬 `eval`을 이용한 계산 수행 등 구체적인 구현 기법을 접하였습니다.

- **시나리오 실습:** 뉴스 요약, 레시피 안내, 여행 일정 수립 **세 가지 예제를 단계별로 실행**하면서, 에이전트가 도구를 사용하여 주어진 과제를 해결하는 과정을 체험했습니다. 에이전트의 내부 로그를 통해 도구 호출 및 응답 과정을 확인하고, 최종 출력물을 통해 도구들이 어떻게 결합되어 활용되었는지 배웠습니다.  
  - 뉴스 시나리오에서는 **실시간 정보**를 얻기 위해 웹 검색/스크래핑 도구를 활용했고, 
  - 레시피 시나리오에서는 **구조화된 정보**(재료/레시피)를 수집해 가공하는 데 도구를 사용했으며, 
  - 여행 시나리오에서는 **복잡한 계산과 다단계 정보 수집**을 도구들로 해결했습니다.

- **디버깅과 도구 입력 형식:** 실습 중 언급된 것처럼, **도구의 입력 형식**이 매우 중요합니다. 웹 스크래퍼에는 **정확한 URL**이 들어가야 하고, 계산기에는 **올바른 수학 표현식 문자열**이 전달되어야 합니다. 만약 에이전트가 잘못된 형식의 입력을 주면 도구가 `"내용을 찾을 수 없습니다."`나 `"계산 오류"` 같은 메시지를 반환하게 됩니다. `verbose=True` 로그를 통해 이러한 문제를 쉽게 진단할 수 있으며, 프롬프트를 조정하거나 추가적인 힌트를 줘서 에이전트가 올바르게 도구를 쓰도록 유도할 수 있습니다. **에이전트와 도구 간의 인터페이스를 명확히 이해**하는 것이 중요함을 배웠습니다.

마지막으로, 외부 도구를 적절히 활용함으로써 **멀티 에이전트 시스템의 능력이 크게 향상**될 수 있다는 것을 확인했습니다. 단일 LLM 에이전트로는 어려웠을 문제들도, 검색 및 계산 등의 도구를 쓰면 훨씬 수월하게 해결할 수 있었습니다. 이처럼 **도구 연동은 지능형 에이전트의 현실 세계 적용력을 높이는 핵심 요소**입니다.

이번 실습에서 배운 내용을 토대로, 여러분은 CrewAI에 새로운 도구를 추가하거나, 다른 시나리오에 현재의 도구들을 응용해볼 수 있습니다. 예를 들어, 여러 에이전트를 hierarchically 구성하여 더 복잡한 문제를 해결하는 방향으로 나아갈 수 있습니다. 

다음 수업에서는 이러한 내용을 발전시켜 **복수의 에이전트들이 협력하거나 계층적으로 작업을 분담하는 시나리오**를 다룰 예정입니다.

수고하셨습니다! 이번 실습을 통해 얻은 경험을 바탕으로, 앞으로도 다양한 도구들을 에이전트와 결합하여 창의적인 해결책을 모색해 보세요. 💡

